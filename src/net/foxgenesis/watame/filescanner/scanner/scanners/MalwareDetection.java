package net.foxgenesis.watame.filescanner.scanner.scanners;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.foxgenesis.watame.filescanner.MalwareType;
import net.foxgenesis.watame.filescanner.scanner.AttachmentData;
import net.foxgenesis.watame.filescanner.scanner.AttachmentException;
import net.foxgenesis.watame.filescanner.scanner.AttachmentScanner;

/**
 * Attachment scanner used to check if an attachment contains malware
 * 
 * @author Spaz-Master, Ashley
 *
 */
public class MalwareDetection implements AttachmentScanner {

	private static final Logger logger = LoggerFactory.getLogger("MalwareDetection");

	private static final byte[] MAL_HINT = { 0x6f, 0x62, 0x6a, 0x53, 0x68, 0x65, 0x6c, 0x6c, 0x2e, 0x45, 0x6e, 0x76,
			0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x28 };
	private static final byte[] MAL_TEST = { 0x58, 0x35, 0x4f, 0x21, 0x50, 0x25, 0x40, 0x41, 0x50, 0x5b, 0x34, 0x5c,
			0x50, 0x5a, 0x58, 0x35, 0x34, 0x28, 0x50, 0x5e, 0x29, 0x37, 0x43, 0x43, 0x29, 0x37, 0x7d, 0x24, 0x45, 0x49,
			0x43, 0x41, 0x52, 0x2d, 0x53, 0x54, 0x41, 0x4e, 0x44, 0x41, 0x52, 0x44, 0x2d, 0x41, 0x4e, 0x54, 0x49, 0x56,
			0x49, 0x52, 0x55, 0x53, 0x2d, 0x54, 0x45, 0x53, 0x54, 0x2d, 0x46, 0x49, 0x4c, 0x45, 0x21, 0x24, 0x48, 0x2b,
			0x48, 0x2a };
	private static final int MAL_HINT_LENGTH = MAL_HINT.length, MAL_TEST_LENGTH = MAL_TEST.length;

	/**
	 * performs completable future test of contents of files for malware
	 * 
	 * @author Spaz-Master, Ashley
	 * @param in         - bytes of file to test
	 * @param msg        - Message object of discord message
	 * @param attachment - Attachment object of the the file
	 */
	@Override
	public CompletableFuture<Void> testAttachment(byte[] in, AttachmentData attachment) {
		final int dataSize = in.length;

		CompletableFuture<Void> out = new CompletableFuture<>();

		CompletableFuture<MalwareType> hintFuture = CompletableFuture.supplyAsync(() -> {
			int hits = 0;

			for (int i = 0; i < dataSize; i++) {
				if (in[i] == MAL_HINT[hits])
					hits++;
				else
					hits = 0;

				if (hits == MAL_HINT_LENGTH)
					return MalwareType.OBJSHELL;
			}
			return MalwareType.NONE;
		});

		CompletableFuture.supplyAsync(() -> {
			int hits = 0;

			for (int i = 0; i < dataSize; i++) {
				if (in[i] == MAL_TEST[hits])
					hits++;
				else
					hits = 0;

				if (hits == MAL_TEST_LENGTH)
					return MalwareType.TEST;
			}
			return MalwareType.NONE;
		}).thenAcceptBothAsync(hintFuture, (test, hint) -> {
			MalwareType result = MalwareType.fromID(Math.max(test.id, hint.id));

			if (result != MalwareType.NONE) {
				logger.debug("Detected malicious file: {}", result);
				out.completeExceptionally(new AttachmentException(result.result));
				return;
			}
			out.complete(null);
		}).orTimeout(15, TimeUnit.SECONDS).exceptionally(err -> {
			out.completeExceptionally(err);
			return null;
		});

		return out;
	}

	@Override
	public boolean shouldTest(AttachmentData attachment) { return true; }
}
