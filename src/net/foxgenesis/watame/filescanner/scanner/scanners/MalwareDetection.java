package net.foxgenesis.watame.filescanner.scanner.scanners;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.foxgenesis.watame.filescanner.MalwareType;
import net.foxgenesis.watame.filescanner.scanner.AttachmentData;
import net.foxgenesis.watame.filescanner.scanner.AttachmentException;
import net.foxgenesis.watame.filescanner.scanner.AttachmentScanner;

/**
 * Attachment scanner used to check if an attachment contains malware
 * 
 * @author Spaz-Master, Ashley
 *
 */
public class MalwareDetection implements AttachmentScanner {

	private static final Logger logger = LoggerFactory.getLogger("MalwareDetection");

	private static final byte[] MAL_HINT = { 0x6f, 0x62, 0x6a, 0x53, 0x68, 0x65, 0x6c, 0x6c, 0x2e, 0x45, 0x6e, 0x76,
			0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x28 };
	private static final byte[] MAL_TEST = { 0x58, 0x35, 0x4f, 0x21, 0x50, 0x25, 0x40, 0x41, 0x50, 0x5b, 0x34, 0x5c,
			0x50, 0x5a, 0x58, 0x35, 0x34, 0x28, 0x50, 0x5e, 0x29, 0x37, 0x43, 0x43, 0x29, 0x37, 0x7d, 0x24, 0x45, 0x49,
			0x43, 0x41, 0x52, 0x2d, 0x53, 0x54, 0x41, 0x4e, 0x44, 0x41, 0x52, 0x44, 0x2d, 0x41, 0x4e, 0x54, 0x49, 0x56,
			0x49, 0x52, 0x55, 0x53, 0x2d, 0x54, 0x45, 0x53, 0x54, 0x2d, 0x46, 0x49, 0x4c, 0x45, 0x21, 0x24, 0x48, 0x2b,
			0x48, 0x2a };
	private static final int MAL_HINT_LENGTH = MAL_HINT.length, MAL_TEST_LENGTH = MAL_TEST.length;

	/**
	 * performs completable future test of contents of files for malware
	 * 
	 * @author Spaz-Master, Ashley
	 * 
	 * @param in         - bytes of file to test
	 * @param attachment - Attachment object of the the file
	 * @param executor   - asynchronous task executor
	 */
	@Override
	public CompletableFuture<Void> testAttachment(byte[] in, AttachmentData attachment, Executor executor) {
		// Code ready for pipes
//		CompletableFuture<Boolean> hintFuture2 = CompletableFuture.supplyAsync(() -> {
//			try {
//				return matchArrayInStream(new ByteArrayInputStream(in), MAL_HINT);
//			} catch (IOException e) {
//				throw new CompletionException(e);
//			}
//		}, executor);
//
//		return CompletableFuture.supplyAsync(() -> {
//			try {
//				return matchArrayInStream(new ByteArrayInputStream(in), MAL_TEST);
//			} catch (IOException e) {
//				throw new CompletionException(e);
//			}
//		}, executor).thenCombineAsync(hintFuture2,
//				(test, hint) -> test ? MalwareType.TEST : hint ? MalwareType.OBJSHELL : MalwareType.NONE, executor)
//				.thenAcceptAsync(type -> {
//					if (type != MalwareType.NONE) {
//						logger.debug("Detected malicious file: {}", type);
//						throw new CompletionException(new AttachmentException(type.result));
//					}
//				}, executor).orTimeout(15, TimeUnit.SECONDS);

		final int dataSize = in.length;

		CompletableFuture<MalwareType> hintFuture = CompletableFuture.supplyAsync(() -> {
			int hits = 0;
			for (int i = 0; i < dataSize; i++) {
				if (in[i] == MAL_HINT[hits])
					hits++;
				else
					hits = 0;

				if (hits == MAL_HINT_LENGTH)
					return MalwareType.OBJSHELL;
			}
			return MalwareType.NONE;
		}, executor);

		return CompletableFuture.supplyAsync(() -> {
			int hits = 0;

			for (int i = 0; i < dataSize; i++) {
				if (in[i] == MAL_TEST[hits])
					hits++;
				else
					hits = 0;

				if (hits == MAL_TEST_LENGTH)
					return MalwareType.TEST;
			}
			return MalwareType.NONE;
		}, executor).thenAcceptBothAsync(hintFuture, (test, hint) -> {
			MalwareType result = MalwareType.fromID(Math.max(test.id, hint.id));

			if (result != MalwareType.NONE) {
				logger.debug("Detected malicious file: {}", result);
				throw new CompletionException(new AttachmentException(result.result));
			}
		}, executor).orTimeout(15, TimeUnit.SECONDS);
	}

	@Override
	public boolean shouldTest(AttachmentData attachment) {
		return attachment.isImage() || attachment.isVideo();
	}

	@SuppressWarnings("unused")
	private static boolean matchArrayInStream(InputStream in, byte[] arr) throws IOException {
		// Not using Objects.requireNonNull because of IDE closable resource check
		if (in == null)
			throw new NullPointerException("InputStream must not be null!");

		Objects.requireNonNull(arr);

		int length = arr.length;
		if (length == 0)
			throw new IllegalArgumentException("Array must not be empty!");

		int hits = 0;
		int data = -1;

		try (BufferedInputStream b = in instanceof BufferedInputStream ? (BufferedInputStream) in
				: new BufferedInputStream(in)) {
			while ((data = b.read()) != -1) {
				hits = data == arr[hits] ? hits + 1 : 0;
				if (hits == length)
					return true;
			}
			return false;
		}
	}
}
